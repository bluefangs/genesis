---
description: Architectural considerations and coding guidelines and development
globs: *
alwaysApply: true
---
### Architectural Guidelines:

- **Always write JavaScript (NO TypeScript).**
- **Keep code modular, performant, and production-ready.** Ensure you write simple code instead of over-engineered or over-optimized difficult code.
- **Write verbose comments:**
  - Document EVERY function and method with comprehensive JSDoc comments
  - Explain complex logic with detailed inline comments
  - Include reasoning behind implementation decisions
  - Comment all constants and configuration values
  - Use block comments to separate logical code sections
  - Document edge cases and potential issues
  - Explain security considerations in all authentication-related code
- **Ensure security measures are integrated into every implementation.**

- **ALWAYS include sidebar and navbar in all dashboard pages**:

  - The sidebar and navbar are considered global static elements and MUST appear in EVERY page
  - Use the `DashboardLayout` component from `@/app/(core)/components/dashboard/DashboardLayout.jsx` for all dashboard pages
  - NEVER create pages that don't include these navigation elements
  - For platform-level pages that need to be accessed through the dashboard:
    - Create a public route wrapper component that uses the DashboardLayout
    - Use props like `title`, `parentPath`, and `parentLabel` to provide context in the breadcrumb
  - CORRECT: Wrapping components with DashboardLayout:
    ```jsx
    <DashboardLayout title="Page Title">
      <YourPageContent />
    </DashboardLayout>
    ```
  - INCORRECT: Creating standalone pages without the dashboard layout

- **ALWAYS follow the platform vs. application separation pattern**:

  - Platform code belongs in `src/app/(core)/`
  - Application code belongs in `src/app/(application)/`
  - Example considerations: auth and login is platform wide and hence must be in (core)
  - Business logic pertaining to application alone resides in (application). Ask the user each time you are unsure.
  - Avoid placing components directly in the root app directory. Instead, use route adapters as needed (see URL structure guidelines below).

- **ALWAYS maintain URL path/directory separation**:

  - Use route adapter pattern for important URL paths
  - Although most code should be in `(core)` or `(application)` directories, specific URLs might need to be preserved
  - For routes like `/dashboard` or `/login`, create thin adapter pages that import from the appropriate core or application directory:

    ```jsx
    // src/app/login/page.js - URL adapter
    "use client";

    import { LoginContent } from "@/app/(core)/auth/login/components/LoginContent.jsx";

    export default function LoginPage() {
      return <LoginContent />;
    }
    ```

  - This maintains both URL structure and core/application separation

- **ALWAYS follow the models directory organization**:

  - Platform data models go in `src/models/(core)/`
  - Application-specific models go in `src/models/(application)/`
  - CORRECT import for platform models: `import { User } from "@/models/core/user";`
  - CORRECT import for application models: `import { Product } from "@/models/application/product"

- **ALWAYS follow the API routes organization**:

  - Platform API endpoints go in `src/app/api/core/`
  - Application-specific endpoints go in `src/app/api/application/`
  - Use logical subdirectories for related endpoints:
    - `src/app/api/core/auth/` for authentication endpoints
    - `src/app/api/core/users/` for user management
    - `src/app/api/application/[domain]/` for domain-specific endpoints
  - Apply consistent security patterns across all API routes
  - Guidelines for API route placement:
    - If an API route provides platform functionality (auth, users, system) or is used by multiple application features, it belongs in `/api/core/`
    - If an API route is specific to application business logic, it belongs in `/api/application/`
  - When replacing the application:
    - Keep all API routes in `/api/core/` directory
    - Remove or replace API routes in `/api/application/` directory

- **ALWAYS use ShadCN's official installation method**:

  - Use CLI command `npx shadcn@latest add [component-name]` for all components
  - NEVER manually create ShadCN components
  - Follow the official ShadCN documentation for component implementation
  - ALWAYS check for component dependencies when installing new components
    - Before using a component, ensure it and all its dependencies have been installed.
  - Verify component compatibility and dependencies in the ShadCN UI documentation

- **ALWAYS use the universal structured logging system**:

  - Import logger from `@/lib/clientLogger` for ALL logging needs in client components (NEVER use console.log)
  - For server components and API routes, import logger from `@/lib/logger`
  - For middleware, import logger from `@/lib/edgeLogger` (Edge Runtime compatible version)
  - NEVER import the server-side logger (`@/lib/logger`) in client components or middleware
  - NEVER import `universalLogger` in client components as it depends on Node.js modules unavailable in the browser
  - Set user context for user-specific logs: `logger.setUser(user)`
  - Clear user context when logging out: `logger.clearUser()`

  - **Audit Logging Requirements**:
    - ALWAYS use `logger.audit()` for all authentication events (login/logout/session management)
    - ALWAYS use `logger.audit()` for access to sensitive user data
    - ALWAYS use `logger.audit()` for critical data modifications
    - ALWAYS use `logger.audit()` for permission/role changes
    - Include standardized fields in ALL audit logs:
      - `action` - Standardized action type (e.g., "login_successful", "data_access")
      - `timestamp` - ISO 8601 formatted date/time
      - `userId` - User who performed the action (when available)
      - `clientInfo` - Object containing user agent, URL, and other client context
    - NEVER include sensitive data (passwords, tokens, complete credit card numbers) in audit logs
    - For server-side audit logs, always include IP address and user agent information
    - Always use descriptive, standardized messages for similar events
    - See `docs/coding_guidelines/AUDIT_LOGGING.md` for complete audit logging standards

- **ALWAYS use comprehensive JSDoc documentation**:

  - ALL functions, methods, and components MUST have JSDoc-style comments
  - Document ALL parameters, return values, and thrown exceptions
  - Include clear descriptions of what each function does and its purpose
  - Use proper JSDoc tags (@param, @returns, @throws, etc.)
  - Include code examples for complex functions where applicable
  - Document all side effects (state changes, network requests, etc.)
  - Be extremely verbose with comments explaining complex logic
  - Comment all constants and configuration values with their purpose
  - Example JSDoc format:

    ```javascript
    /**
     * Description of what the function does.
     * Additional details about behavior, edge cases, or implementation notes.
     *
     * @param {string} paramName - Description of the parameter
     * @param {Object} objectParam - Description of object parameter
     * @param {string} objectParam.property - Description of nested property
     * @returns {ReturnType} Description of the return value
     * @throws {ErrorType} Description of when/why errors are thrown
     *
     * @example
     * // Example usage of the function
     * const result = functionName('example');
     * console.log(result); // Expected output
     */
    ```

  - Every file should have a top-level comment explaining its purpose
  - Comment blocks should be used to separate logical sections of code
  - Internal implementation details should be documented to aid maintainability

- **ALWAYS ensure proper theme support**:

  - Every component must support both light and dark themes
  - Use Tailwind's dark mode classes (e.g., `dark:bg-gray-800`) for theme-specific styling
  - Use CSS variables for colors that change with theme
  - Test all components in both light and dark modes
  - Use `useTheme()` from next-themes for theme toggling functionality
  - Always provide sufficient color contrast in both themes for accessibility
  - Use semantic color names in the design system, not literal colors (e.g., `text-primary` instead of `text-blue-500`)

- **ALWAYS follow correct Next.js import patterns**:

  - For route groups with parentheses, ALWAYS include parentheses in import paths
    - CORRECT: `import { Component } from './/(core)/components'`
    - INCORRECT: `import { Component } from './core/components'`
  - Use absolute imports with `@/` alias for better maintainability
    - RECOMMENDED: `import { Component } from '@/app/(core)/components'`
  - Be consistent with file extensions across the project
  - When installing packages that create pages, check for duplicate pages and resolve conflicts
  - Always verify paths after scaffolding or generating code
  - **Standardize on .jsx extension for React components**
    - All React components should use the .jsx file extension
    - Utility files and non-component code can use .js extension
    - Never create duplicate implementations of the same component
    - When importing .jsx files, explicitly include the extension:
      - CORRECT: `import { Component } from "@/components/ui/Component.jsx";`
      - INCORRECT: `import { Component } from "@/components/ui/Component";` (will try to load Component.js)
    - After installing new packages or components, run a duplication check:
      - Look for multiple files with similar names (e.g., `Component.js` and `Component.jsx`)
      - Check for multiple implementations of the same functionality
      - Remove unused or duplicate implementations promptly

- **Avoid using relative imports that traverse multiple directories (e.g., `../../../`)**:

  - CORRECT: `import { useAuth } from "@/app/(core)/hooks/useAuth";`
  - INCORRECT: `import { useAuth } from "../../../hooks/useAuth";`

- **ALWAYS optimize for performance and reactivity**:

  - **Choose the right rendering strategy**:

    - Use Server Components (default in app router) for static or server-rendered content
    - Use Client Components (`"use client"`) only for interactive parts that need browser APIs or hooks
    - Consider streaming with Suspense for progressively loading complex UIs
    - CORRECT: Keep data fetching in Server Components where possible
    - INCORRECT: Making every component a Client Component unnecessarily

  - **Implement efficient data fetching and reactivity**:

    - Use SWR or React Query for client-side data fetching with automatic revalidation
    - Consider Server-Sent Events for real-time, one-way updates (metrics, notifications)
    - Use WebSockets for bi-directional real-time communication
    - Leverage the power of React's Context API for state that spans multiple components
    - Use the right state management solution for your needs (React state, Zustand, Redux)
    - CORRECT: `useSWR('/api/data', fetcher, { refreshInterval: 3000 })`
    - INCORRECT: Polling with `setInterval` and direct fetch calls

  - **Apply performance optimizations**:

    - Implement proper caching strategies (SWR, Redis) for expensive data operations
    - Use Incremental Static Regeneration for pages that change infrequently
    - Optimize image loading with Next.js Image component
    - Split large components into smaller chunks for better code splitting
    - Lazy load non-critical components with dynamic imports
    - Add appropriate revalidation periods to static pages that need updates
    - CORRECT: `export const revalidate = 60; // Revalidate at most once per minute`
    - INCORRECT: Setting overly short revalidation periods or not using revalidation at all

  - **Balance server and client rendering**:

    - Render static content server-side for fastest initial load
    - Hydrate interactive elements client-side as needed
    - Use Suspense boundaries to progressively enhance the UI
    - Consider selective hydration for complex interactive components
    - CORRECT: Using React.Suspense for non-critical parts of the UI
    - INCORRECT: Loading all interactive components at once, blocking the main thread

  - **Ensure smooth UI updates**:

    - Use React Transitions for smoother state updates
    - Implement optimistic UI updates for better perceived performance
    - Debounce or throttle rapid user inputs and expensive calculations
    - CORRECT: `useTransition` hook for non-blocking UI updates
    - INCORRECT: Direct state updates that cause UI jank

  - **Optimize visualizations and reactive data representations**:
    - Server-render initial visualization state for fast initial load
    - Use appropriate chart libraries that support SSR when possible (recharts, visx)
    - Implement client-side updates for real-time data changes
    - Consider webworkers for complex data processing in visualizations
    - Lazy-load visualization components to reduce initial bundle size
    - CORRECT: Rendering chart shells server-side, populating with data client-side
    - INCORRECT: Relying solely on client-side rendering for all visualizations
    - Implement virtualization for displaying large datasets (react-window, react-virtualized)
    - Use proper memoization techniques to prevent unnecessary re-renders
    - Consider WebGL-based visualizations for exceptionally complex data
    - CORRECT: Selectively updating only changed data points in real-time visualizations
    - INCORRECT: Re-rendering entire complex charts on every small data update

- **ALWAYS implement hydration safety patterns for client components**:

  - To prevent hydration mismatches, especially with theme-related attributes, apply the following pattern to ALL client components:

    ```jsx
    "use client";

    import { useEffect, useState } from "react";

    export function MyComponent() {
      // State for hydration detection
      const [isMounted, setIsMounted] = useState(false);

      // Handle component mounting for hydration
      useEffect(() => {
        // Use setTimeout to ensure client-side hydration completes
        const timer = setTimeout(() => {
          setIsMounted(true);
        }, 0);

        return () => clearTimeout(timer);
      }, []);

      // Show minimal placeholder during server-side rendering
      if (!isMounted) {
        return <div className="min-h-[your-component-height] animate-pulse">Loading...</div>;
      }

      // Render full component after client-side hydration
      return <YourActualComponentContent />;
    }
    ```

  - Apply this pattern to ALL components that:
    - Use theme-dependent styling or components
    - Include the `useTheme()` hook from next-themes
    - Render content that depends on client-side state or browser APIs
    - Need to avoid theme-related class name or style mismatches
  - Ensure conditional rendering of components like Toaster that depend on theme:
    - CORRECT: `{isMounted && <Toaster />}`
    - INCORRECT: `<Toaster />`
  - Use placeholder content during server-side rendering that matches the expected dimensions of the fully rendered component to avoid layout shift
  - Delay access to browser APIs and localStorage until after mounting is complete
  - ALWAYS apply this pattern to authentication-related components and pages
  - Consider extracting this pattern into a reusable higher-order component or hook:

    ```jsx
    // src/hooks/useHydration.js
    export function useHydration() {
      const [isMounted, setIsMounted] = useState(false);

      useEffect(() => {
        const timer = setTimeout(() => {
          setIsMounted(true);
        }, 0);

        return () => clearTimeout(timer);
      }, []);

      return isMounted;
    }
    ```

    - Leverage official documentation of ShadCN https://ui.shadcn.com/docs/ for implemenataion of shadcn components
    - Leverage official documentation of nextjs in general for implementation https://nextjs.org/docs
